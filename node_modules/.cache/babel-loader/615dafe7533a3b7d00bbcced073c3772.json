{"ast":null,"code":"var _jsxFileName = \"/Users/alex/projects/tasks_timer/src/components/Chart.js\";\nimport React, { useState } from \"react\";\nimport { ComposedChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Legend } from \"recharts\";\nimport { connect } from \"react-redux\";\nimport moment from \"moment\";\nimport { getTasks } from \"../redux/store\";\nimport GenerateTenTasksButton from \"./GenerateTenTasksButton\";\nimport randomColor from \"../helpers/randomColor\";\nimport { deleteAllTasks } from \"../redux/actions\";\n\nconst Chart = ({\n  tasks,\n  deleteAllTasksFromLog\n}) => {\n  const data = [];\n  const [isClickedGenerateButton, setClickedGenerateButton] = useState(null);\n  const [generatedTasks, setGeneratedTasks] = useState([]);\n\n  const randomTaskDuration = () => {\n    const randomMinutes = (min, max) => {\n      return Math.floor(Math.random() * (max - min + 1) + min);\n    };\n\n    const random = randomMinutes(10, 90);\n    const randomMS = random * 60 * 1000;\n    return moment.utc(randomMS).format(\"HH:mm:ss\");\n  };\n\n  const breakBetweenGenerated10Tasks = () => {\n    const randomMinutes = (min, max) => {\n      return Math.floor(Math.random() * (max - min + 1) + min);\n    };\n\n    return moment.utc(randomMinutes(1, 15) * 60 * 1000).format(\"HH:mm:ss\");\n  };\n\n  const totalTime = (startTime, taskDuration) => {\n    const durations = [startTime, taskDuration];\n    const totalDurations = durations.slice(1).reduce((prev, cur) => moment.duration(cur).add(prev), moment.duration(durations[0]));\n    return moment.utc(totalDurations.asMilliseconds()).format(\"HH:mm:ss\");\n  };\n\n  const generateTenTasks = () => {\n    let generatedTasks = [];\n\n    for (let i = 0; i < 10; i++) {\n      let startTime;\n\n      if (i === 0) {\n        startTime = \"06:00:00\";\n      } else {\n        startTime = totalTime(generatedTasks[i - 1].endTime, breakBetweenGenerated10Tasks());\n      }\n\n      let taskDuration = randomTaskDuration();\n      let endTime = totalTime(startTime, taskDuration);\n      generatedTasks.push({\n        startTime: startTime,\n        taskDuration: taskDuration,\n        endTime: endTime,\n        id: i + 1,\n        taskColor: randomColor()\n      });\n    }\n\n    setClickedGenerateButton(false);\n    return generatedTasks;\n  };\n\n  if (isClickedGenerateButton) {\n    setGeneratedTasks(generateTenTasks());\n  }\n\n  const needTasks = hour => {\n    if (isClickedGenerateButton !== null) {\n      return [...generatedTasks].filter(({\n        startTime\n      }) => startTime.split(\":\").map(el => +el)[0] === hour);\n    } else {\n      return tasks.filter(({\n        startTime\n      }) => startTime.split(\":\").map(el => +el)[0] === hour);\n    }\n  };\n\n  const durationsTasksInThisHour = tasks => {\n    const durations = [];\n\n    for (let i = 0; i < tasks.length; i++) {\n      const task = tasks[i];\n      const hourStart = task.startTime.split(\":\")[0];\n      const hourEnd = task.endTime.split(\":\")[0];\n\n      if (hourStart === hourEnd) {\n        durations.push(task.taskDuration);\n      } else {\n        const startTimeMoment = moment(task.startTime, \"HH:mm:ss\");\n        const nextHour = +task.startTime.split(\":\")[0] + 1;\n        let nextHourString = \"\";\n\n        if (nextHour > 9) {\n          nextHourString = `${nextHour}:00:00`;\n        } else {\n          nextHourString = `0${nextHour}:00:00`;\n        }\n\n        let nextHourMoment = moment(nextHourString, \"HH:mm:ss\");\n        durations.push(moment.utc(nextHourMoment.diff(startTimeMoment)).format(\"HH:mm:ss\"));\n      }\n    }\n\n    return durations;\n  };\n\n  let timeDurationFromPrevTask = null;\n\n  const minutesInThisHour = hour => {\n    let arrayOfMinutesInThisHour = [];\n    let tasks = needTasks(hour);\n    let minutesInThisHourFromPrevTask = null;\n\n    if (timeDurationFromPrevTask !== null) {\n      let duration = +timeDurationFromPrevTask.slice(0, 2);\n\n      if (duration >= 1) {\n        minutesInThisHourFromPrevTask = \"00:60:00\";\n        let timeDurationFromPrevTaskMoment = moment(timeDurationFromPrevTask, \"HH:mm:ss\");\n        let oneHourMoment = moment(\"01:00:00\", \"HH:mm:ss\");\n        timeDurationFromPrevTask = moment.utc(timeDurationFromPrevTaskMoment.diff(oneHourMoment)).format(\"HH:mm:ss\");\n      } else {\n        minutesInThisHourFromPrevTask = timeDurationFromPrevTask;\n        timeDurationFromPrevTask = null;\n      }\n    }\n\n    let durations = [minutesInThisHourFromPrevTask, ...durationsTasksInThisHour(tasks)];\n\n    for (let i = 0; i < durations.length; i++) {\n      const duration = durations[i];\n\n      if (durations[i] === null) {\n        continue;\n      }\n\n      arrayOfMinutesInThisHour.push(+duration.split(\":\")[1]);\n      minutesInThisHourFromPrevTask = null;\n    }\n\n    if (tasks.length > 0) {\n      const lastTaskInThisHour = tasks[tasks.length - 1];\n      const startHourInLastTaskInThisHour = +lastTaskInThisHour.startTime.split(\":\")[0];\n      const endHourInLastTaskInThisHour = +lastTaskInThisHour.endTime.split(\":\")[0];\n\n      if (endHourInLastTaskInThisHour - startHourInLastTaskInThisHour > 0) {\n        const timeDurationFromPrevTaskMoment = moment(lastTaskInThisHour.taskDuration, \"HH:mm:ss\");\n        const timeDurationFromPrevHourMoment = moment(durations[durations.length - 1], \"HH:mm:ss\");\n        timeDurationFromPrevTask = moment.utc(timeDurationFromPrevTaskMoment.diff(timeDurationFromPrevHourMoment)).format(\"HH:mm:ss\");\n      }\n    }\n\n    return arrayOfMinutesInThisHour;\n  };\n\n  let prevTaskId;\n\n  const addTaskDurationToData = hour => {\n    const objOfTasksDuration = {};\n    const arr = minutesInThisHour(hour);\n    const prevTasks = needTasks(hour - 1);\n    const tasks = needTasks(hour);\n\n    if (prevTasks.length > 0) {\n      prevTaskId = prevTasks[prevTasks.length - 1].id;\n    }\n\n    if (arr.length > 0) {\n      for (let j = 0; j < arr.length; j++) {\n        let task = tasks[j];\n        let taskName = null;\n\n        if (arr.length === tasks.length) {\n          taskName = `Task-${task.id} in hour-${hour}`;\n          objOfTasksDuration[taskName] = arr[j];\n        }\n\n        if (arr.length !== 0 && tasks.length === 0) {\n          taskName = `Task-${prevTaskId} in hour-${hour}`;\n          objOfTasksDuration[taskName] = arr[j];\n        }\n\n        if (arr.length > tasks.length) {\n          if (j === 0) {\n            taskName = `Task-${prevTaskId} in hour-${hour}`;\n            objOfTasksDuration[taskName] = arr[j];\n          }\n\n          if (j > 0) {\n            taskName = `Task-${tasks[j - 1].id} in hour-${hour}`;\n            objOfTasksDuration[taskName] = arr[j];\n          }\n        }\n      }\n    }\n\n    return objOfTasksDuration;\n  };\n\n  for (let i = 0; i < 24; i++) {\n    if (i <= 4) {\n      data.push({\n        minutes: i * 15,\n        hour: i,\n        ...addTaskDurationToData(i)\n      });\n    } else {\n      data.push({\n        hour: i,\n        ...addTaskDurationToData(i)\n      });\n    }\n  }\n\n  let prevTaskColor;\n\n  const findTaskColor = (taskName, hour) => {\n    let taskId = +taskName.split(\" \")[0].replace(/Task-/gi, \"\");\n    let needTask = needTasks(hour).filter(el => el.id === taskId);\n    let [obj] = needTask;\n\n    if (obj) {\n      prevTaskColor = obj.taskColor;\n      return obj.taskColor;\n    } else {\n      return prevTaskColor;\n    }\n  };\n\n  const dataSeries = (data, hour) => {\n    let series = [];\n    let dataKeys = Object.keys(data[hour]);\n\n    for (const key of dataKeys) {\n      if (key !== \"hour\" && key !== \"minutes\") {\n        series.push(React.createElement(Bar, {\n          dataKey: key,\n          barSize: 20,\n          stackId: \"a\",\n          fill: findTaskColor(key, hour),\n          key: key,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 287\n          },\n          __self: this\n        }));\n      }\n    }\n\n    return series;\n  };\n\n  return React.createElement(React.Fragment, null, React.createElement(GenerateTenTasksButton, {\n    clickFunction: () => {\n      setClickedGenerateButton(true);\n      deleteAllTasksFromLog();\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 303\n    },\n    __self: this\n  }), React.createElement(ResponsiveContainer, {\n    width: \"90%\",\n    aspect: 6.0 / 2.0,\n    height: 300,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 311\n    },\n    __self: this\n  }, React.createElement(ComposedChart, {\n    data: data,\n    margin: {\n      top: 20,\n      left: 20\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 312\n    },\n    __self: this\n  }, React.createElement(CartesianGrid, {\n    stroke: \"#f5f5f5\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 319\n    },\n    __self: this\n  }), React.createElement(XAxis, {\n    dataKey: \"hour\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 320\n    },\n    __self: this\n  }), React.createElement(YAxis, {\n    dataKey: \"minutes\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 321\n    },\n    __self: this\n  }), React.createElement(Tooltip, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 322\n    },\n    __self: this\n  }), React.createElement(Legend, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 323\n    },\n    __self: this\n  }), data.map((_, i) => dataSeries(data, i)))));\n};\n\nconst mapStateToProps = state => ({\n  tasks: getTasks(state)\n});\n\nconst mapDispatchToProps = dispatch => ({\n  deleteAllTasksFromLog: () => dispatch(deleteAllTasks())\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Chart);","map":{"version":3,"sources":["/Users/alex/projects/tasks_timer/src/components/Chart.js"],"names":["React","useState","ComposedChart","Bar","XAxis","YAxis","CartesianGrid","Tooltip","ResponsiveContainer","Legend","connect","moment","getTasks","GenerateTenTasksButton","randomColor","deleteAllTasks","Chart","tasks","deleteAllTasksFromLog","data","isClickedGenerateButton","setClickedGenerateButton","generatedTasks","setGeneratedTasks","randomTaskDuration","randomMinutes","min","max","Math","floor","random","randomMS","utc","format","breakBetweenGenerated10Tasks","totalTime","startTime","taskDuration","durations","totalDurations","slice","reduce","prev","cur","duration","add","asMilliseconds","generateTenTasks","i","endTime","push","id","taskColor","needTasks","hour","filter","split","map","el","durationsTasksInThisHour","length","task","hourStart","hourEnd","startTimeMoment","nextHour","nextHourString","nextHourMoment","diff","timeDurationFromPrevTask","minutesInThisHour","arrayOfMinutesInThisHour","minutesInThisHourFromPrevTask","timeDurationFromPrevTaskMoment","oneHourMoment","lastTaskInThisHour","startHourInLastTaskInThisHour","endHourInLastTaskInThisHour","timeDurationFromPrevHourMoment","prevTaskId","addTaskDurationToData","objOfTasksDuration","arr","prevTasks","j","taskName","minutes","prevTaskColor","findTaskColor","taskId","replace","needTask","obj","dataSeries","series","dataKeys","Object","keys","key","top","left","_","mapStateToProps","state","mapDispatchToProps","dispatch"],"mappings":"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","sourcesContent":["import React, { useState } from \"react\";\nimport {\n  ComposedChart,\n  Bar,\n  XAxis,\n  YAxis,\n  CartesianGrid,\n  Tooltip,\n  ResponsiveContainer,\n  Legend\n} from \"recharts\";\nimport { connect } from \"react-redux\";\nimport moment from \"moment\";\nimport { getTasks } from \"../redux/store\";\nimport GenerateTenTasksButton from \"./GenerateTenTasksButton\";\nimport randomColor from \"../helpers/randomColor\";\nimport { deleteAllTasks }from \"../redux/actions\";\n\nconst Chart = ({ tasks, deleteAllTasksFromLog }) => {\n  const data = [];\n  const [isClickedGenerateButton, setClickedGenerateButton] = useState(null);\n  const [generatedTasks, setGeneratedTasks] = useState([]);\n\n  const randomTaskDuration = () => {\n    const randomMinutes = (min, max) => {\n      return Math.floor(Math.random() * (max - min + 1) + min);\n    };\n    const random = randomMinutes(10, 90);\n    const randomMS = random * 60 * 1000;\n\n    return moment.utc(randomMS).format(\"HH:mm:ss\");\n  };\n\n  const breakBetweenGenerated10Tasks = () => {\n    const randomMinutes = (min, max) => {\n      return Math.floor(Math.random() * (max - min + 1) + min);\n    };\n\n    return moment.utc(randomMinutes(1, 15) * 60 * 1000).format(\"HH:mm:ss\");\n  };\n\n  const totalTime = (startTime, taskDuration) => {\n    const durations = [startTime, taskDuration];\n\n    const totalDurations = durations\n      .slice(1)\n      .reduce(\n        (prev, cur) => moment.duration(cur).add(prev),\n        moment.duration(durations[0])\n      );\n\n    return moment.utc(totalDurations.asMilliseconds()).format(\"HH:mm:ss\");\n  };\n\n  const generateTenTasks = () => {\n    let generatedTasks = [];\n\n    for (let i = 0; i < 10; i++) {\n      let startTime;\n\n      if (i === 0) {\n        startTime = \"06:00:00\";\n      } else {\n        startTime = totalTime(\n          generatedTasks[i - 1].endTime,\n          breakBetweenGenerated10Tasks()\n        );\n      }\n\n      let taskDuration = randomTaskDuration();\n      let endTime = totalTime(startTime, taskDuration);\n\n      generatedTasks.push({\n        startTime: startTime,\n        taskDuration: taskDuration,\n        endTime: endTime,\n        id: i + 1,\n        taskColor: randomColor()\n      });\n    }\n    setClickedGenerateButton(false);\n\n    return generatedTasks;\n  };\n\n  if (isClickedGenerateButton) {\n    setGeneratedTasks(generateTenTasks());\n  }\n\n  const needTasks = hour => {\n    if (isClickedGenerateButton !== null) {\n      return [...generatedTasks].filter(\n        ({ startTime }) => startTime.split(\":\").map(el => +el)[0] === hour\n      );\n    } else {\n      return tasks.filter(\n        ({ startTime }) => startTime.split(\":\").map(el => +el)[0] === hour\n      );\n    }\n  };\n\n  const durationsTasksInThisHour = tasks => {\n    const durations = [];\n\n    for (let i = 0; i < tasks.length; i++) {\n      const task = tasks[i];\n      const hourStart = task.startTime.split(\":\")[0];\n      const hourEnd = task.endTime.split(\":\")[0];\n\n      if (hourStart === hourEnd) {\n        durations.push(task.taskDuration);\n      } else {\n        const startTimeMoment = moment(task.startTime, \"HH:mm:ss\");\n        const nextHour = +task.startTime.split(\":\")[0] + 1;\n        let nextHourString = \"\";\n\n        if (nextHour > 9) {\n          nextHourString = `${nextHour}:00:00`;\n        } else {\n          nextHourString = `0${nextHour}:00:00`;\n        }\n\n        let nextHourMoment = moment(nextHourString, \"HH:mm:ss\");\n\n        durations.push(\n          moment.utc(nextHourMoment.diff(startTimeMoment)).format(\"HH:mm:ss\")\n        );\n      }\n    }\n\n    return durations;\n  };\n\n  let timeDurationFromPrevTask = null;\n\n  const minutesInThisHour = hour => {\n    let arrayOfMinutesInThisHour = [];\n    let tasks = needTasks(hour);\n    let minutesInThisHourFromPrevTask = null;\n\n    if (timeDurationFromPrevTask !== null) {\n      let duration = +timeDurationFromPrevTask.slice(0, 2);\n\n      if (duration >= 1) {\n        minutesInThisHourFromPrevTask = \"00:60:00\";\n        let timeDurationFromPrevTaskMoment = moment(\n          timeDurationFromPrevTask,\n          \"HH:mm:ss\"\n        );\n        let oneHourMoment = moment(\"01:00:00\", \"HH:mm:ss\");\n\n        timeDurationFromPrevTask = moment\n          .utc(timeDurationFromPrevTaskMoment.diff(oneHourMoment))\n          .format(\"HH:mm:ss\");\n      } else {\n        minutesInThisHourFromPrevTask = timeDurationFromPrevTask;\n        timeDurationFromPrevTask = null;\n      }\n    }\n\n    let durations = [\n      minutesInThisHourFromPrevTask,\n      ...durationsTasksInThisHour(tasks)\n    ];\n\n    for (let i = 0; i < durations.length; i++) {\n      const duration = durations[i];\n\n      if (durations[i] === null) {\n        continue;\n      }\n      arrayOfMinutesInThisHour.push(+duration.split(\":\")[1]);\n      minutesInThisHourFromPrevTask = null;\n    }\n\n    if (tasks.length > 0) {\n      const lastTaskInThisHour = tasks[tasks.length - 1];\n      const startHourInLastTaskInThisHour = +lastTaskInThisHour.startTime.split(\n        \":\"\n      )[0];\n      const endHourInLastTaskInThisHour = +lastTaskInThisHour.endTime.split(\n        \":\"\n      )[0];\n\n      if (endHourInLastTaskInThisHour - startHourInLastTaskInThisHour > 0) {\n        const timeDurationFromPrevTaskMoment = moment(\n          lastTaskInThisHour.taskDuration,\n          \"HH:mm:ss\"\n        );\n        const timeDurationFromPrevHourMoment = moment(\n          durations[durations.length - 1],\n          \"HH:mm:ss\"\n        );\n\n        timeDurationFromPrevTask = moment\n          .utc(\n            timeDurationFromPrevTaskMoment.diff(timeDurationFromPrevHourMoment)\n          )\n          .format(\"HH:mm:ss\");\n      }\n    }\n\n    return arrayOfMinutesInThisHour;\n  };\n\n  let prevTaskId;\n\n  const addTaskDurationToData = hour => {\n    const objOfTasksDuration = {};\n    const arr = minutesInThisHour(hour);\n    const prevTasks = needTasks(hour - 1);\n    const tasks = needTasks(hour);\n\n    if (prevTasks.length > 0) {\n      prevTaskId = prevTasks[prevTasks.length - 1].id;\n    }\n\n    if (arr.length > 0) {\n      for (let j = 0; j < arr.length; j++) {\n        let task = tasks[j];\n        let taskName = null;\n\n        if (arr.length === tasks.length) {\n          taskName = `Task-${task.id} in hour-${hour}`;\n          objOfTasksDuration[taskName] = arr[j];\n        }\n\n        if (arr.length !== 0 && tasks.length === 0) {\n          taskName = `Task-${prevTaskId} in hour-${hour}`;\n          objOfTasksDuration[taskName] = arr[j];\n        }\n\n        if (arr.length > tasks.length) {\n          if (j === 0) {\n            taskName = `Task-${prevTaskId} in hour-${hour}`;\n            objOfTasksDuration[taskName] = arr[j];\n          }\n\n          if (j > 0) {\n            taskName = `Task-${tasks[j - 1].id} in hour-${hour}`;\n            objOfTasksDuration[taskName] = arr[j];\n          }\n        }\n      }\n    }\n\n    return objOfTasksDuration;\n  };\n\n  for (let i = 0; i < 24; i++) {\n    if (i <= 4) {\n      data.push({\n        minutes: i * 15,\n        hour: i,\n        ...addTaskDurationToData(i)\n      });\n    } else {\n      data.push({\n        hour: i,\n        ...addTaskDurationToData(i)\n      });\n    }\n  }\n\n  let prevTaskColor;\n\n  const findTaskColor = (taskName, hour) => {\n    let taskId = +taskName.split(\" \")[0].replace(/Task-/gi, \"\");\n    let needTask = needTasks(hour).filter(el => el.id === taskId);\n    let [obj] = needTask;\n\n    if (obj) {\n      prevTaskColor = obj.taskColor;\n      return obj.taskColor;\n    } else {\n      return prevTaskColor;\n    }\n  };\n\n  const dataSeries = (data, hour) => {\n    let series = [];\n    let dataKeys = Object.keys(data[hour]);\n\n    for (const key of dataKeys) {\n      if (key !== \"hour\" && key !== \"minutes\") {\n        series.push(\n          <Bar\n            dataKey={key}\n            barSize={20}\n            stackId=\"a\"\n            fill={findTaskColor(key, hour)}\n            key={key}\n          />\n        );\n      }\n    }\n\n    return series;\n  };\n\n  return (\n    <>\n      <GenerateTenTasksButton\n        clickFunction={\n          () => {\n            setClickedGenerateButton(true);\n            deleteAllTasksFromLog();\n          }\n        }\n      />\n      <ResponsiveContainer width=\"90%\" aspect={6.0 / 2.0} height={300}>\n        <ComposedChart\n          data={data}\n          margin={{\n            top: 20,\n            left: 20\n          }}\n        >\n          <CartesianGrid stroke=\"#f5f5f5\" />\n          <XAxis dataKey=\"hour\" />\n          <YAxis dataKey=\"minutes\" />\n          <Tooltip />\n          <Legend />\n          {data.map((_, i) => dataSeries(data, i))}\n        </ComposedChart>\n      </ResponsiveContainer>\n    </>\n  );\n};\n\nconst mapStateToProps = state => ({\n  tasks: getTasks(state)\n});\n\nconst mapDispatchToProps = dispatch => ({\n  deleteAllTasksFromLog: () => dispatch(deleteAllTasks())\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Chart);\n"]},"metadata":{},"sourceType":"module"}